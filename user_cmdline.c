#include<stdio.h>
#include<stdlib.h>
#include<getopt.h>
#include<string.h>
#include<ctype.h>
#include "pattern_ioctl.h"

int do_ioctl(int, struct user_args_t *);

static const char usage[] = "usage: %s [-l | -a <pattern> | -r <pattern>] /mnt/amfs/\n";
static const char *opt_string = "la:r:h";

void init_structure(struct user_args_t *user_args)
{
	int i;

	user_args->pattern_len = -1;
	for (i = 0; i < PATTERN_MAX_LEN; i++)
		user_args->pattern[i] = 0;
}

/**
 * has_non_ascii_char
 * @str: string to check if it has non-ASCII character/s
 *
 * Determines if str has any non-ASCII character
 *
 * Returns 1 if any non-ASCII character found; else returns 0
 */
int has_non_ascii_char(const char *str)
{
	int i;

	for (i = 0; str[i]; i++)
		if (!isascii(str[i]))
			return 1;
	return 0;
}

/**
 * basic_validations
 * @pattern: string on which validations will be performed
 * @argc: no of arguments passed on commandline
 * @p: pointer to array on which commandline arguments are stored
 *
 * Performs basic validations on user arguments
 *
 * Returns EXIT_FAILURE if any validation fails; zero otherwise
 */
int basic_validations(const char *pattern, int argc, const char *p)
{
	if (!pattern) {
		fprintf(stderr,  usage,  p);
		goto ERR;
	}

	if (strlen(pattern) == 0) {
		fprintf(stderr, "pattern/mount point cannot be of length 0\n");
		goto ERR;
	}

	if (strlen(pattern) > PATTERN_MAX_LEN) {
		fprintf(stderr, "pattern length cannot be greater than 23\n");
		goto ERR;
	}

	if (has_non_ascii_char(pattern)) {
		fprintf(stderr, "%s:non-ascii character detected in password. Password should've valid ASCII character\n", p);
		goto ERR;
	}

	return EXIT_SUCCESS;
ERR:
	return EXIT_FAILURE;
}

int main(int argc,  char **argv)
{
	int c = 0, err, l_flag = 0, a_flag = 0, r_flag = 0, operation = -1;
	struct user_args_t user_args;
	char *mount_point = NULL;
	const char *pattern = NULL;

	init_structure(&user_args);
	while ((c = getopt(argc, argv, opt_string)) != -1) {
		switch (c) {
		case 'l':

			if (l_flag == 0 && operation == -1) {
				operation = 0;
				l_flag = 1;

			} else {
				if (l_flag != 0)
					fprintf(stderr, "%s: You cannot use -l option more than once\n",  argv[0]);
				else if (operation != -1)
					fprintf(stderr, "%s: You cannot use multiple options\n",  argv[0]);
				exit(EXIT_FAILURE);
			}
			break;
		case 'a':
			if (a_flag == 0 && operation == -1) {
				operation = 1;
				a_flag = 1;
				pattern = optarg;
			} else {
				if (a_flag != 0)
					fprintf(stderr, "%s: You cannot use -a option more than once\n",  argv[0]);
				else if (operation != -1)
					fprintf(stderr, "%s: You cannot use multiple options\n",  argv[0]);

				exit(EXIT_FAILURE);
			}
			break;
		case 'r':
			if (r_flag == 0 && operation == -1) {
				operation = 2;
				r_flag = 1;
				pattern = optarg;

			} else {
				if (r_flag != 0)
					fprintf(stderr, "%s: You cannot use -r option more than once\n",
						argv[0]);
				else if (operation != -1)
					fprintf(stderr,
						"%s:Invali multiple options\n",
						argv[0]);
				exit(EXIT_FAILURE);
			}
			break;
		case 'h':
			fprintf(stderr, usage, argv[0]);
			exit(EXIT_FAILURE);
		case '?':
			fprintf(stderr, usage, argv[0]);
			exit(EXIT_FAILURE);
		}
	}

	if (operation == -1) {
		fprintf(stderr,  "%s: missing one of -l/-r/-a option\n", argv[0]);
		fprintf(stderr,  usage,  argv[0]);
		exit(1);
	}

	if (argc - optind != 1) {
		if (argc - optind == 0)
			fprintf(stderr,  "%s: missing mount point\n", argv[0]);
		if (argc - optind >= 2)
			fprintf(stderr,  "%s: only 1 mount point allowed\n",
				argv[0]);
		fprintf(stderr,  usage,  argv[0]);
		exit(1);
	}

	if (r_flag == 1 || a_flag == 1) {
		err = basic_validations(pattern, argc, argv[0]);
		if (err)
			return err;
		strncpy(user_args.pattern, pattern, strlen(pattern) + 1);

		user_args.pattern_len = strlen(user_args.pattern);
	}
	mount_point = argv[optind];

	err = basic_validations(mount_point, argc, argv[0]);
	if (err)
		return err;

	if (!(strcmp(mount_point, "/mnt/amfs") == 0 ||
	      strcmp(mount_point, "/mnt/amfs/") == 0)) {
		fprintf(stderr, "Use /mnt/amfs or /mnt/amfs/ as mount point\n");
		return EXIT_FAILURE;
	}

	err = do_ioctl(operation, &user_args);
	return 0;
}
