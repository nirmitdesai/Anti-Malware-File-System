#include<linux/slab.h>
#include<linux/module.h>
#include<linux/string.h>
#include<linux/uaccess.h>
#include<linux/fs.h>
#include<linux/namei.h>

#include "list.h"

List pattern_list;
/**
 * init_list
 * @list: Pointer to linked list in memory
 *
 * Initializes the linked list
 *
 * Returns nothing
 */
void init_list(List *list)
{
	int i;

	list->full_path = NULL;
	list->size = 0;
	list->head = NULL;
	list->max_pattern_len = -1;
	for (i = 0; i < 58; i++)
		list->hash_table[i] = 0;
}

/**
 * get_newline_index
 * @buf:  user buffer containing data to be scanned
 *
 * Scans the buffer for index of newline.
 *
 * Returns index of newline in buffer; -1 if there's no newline in buffer
 */
int get_newline_index(const char *buf)
{
	char *ret;

	ret = strpbrk(buf, "\n");
	if (!ret)
		return -1;
	return ret - buf;
}

/**
 * contains_malware_pattern
 * @buf:  user buffer containing data to be scanned
 *
 * Scans the buffer for malicious pattern. We iterate over each pattern
 * in linked list and check if it is in user buffer.
 *
 * Returns 1 if buffer has malware pattern; 0 otherwise
 */
int contains_malware_pattern(const char __user *buf)
{
	Node *current_node = pattern_list.head;
	int err = 0;
	char *ret;
	int user_buf_len = strlen(buf);
	char *kern_buf = kmalloc(sizeof(char) * user_buf_len + 1, GFP_KERNEL);

	if (!kern_buf) {
		err = -ENOMEM;
		pr_info("no memory for kernel buffer\n");
		return err;
	}

	if (copy_from_user(kern_buf, buf, user_buf_len)) {
		err = -EFAULT;
		pr_info("error in copying from user buf\n");
		return err;
	}

	kern_buf[user_buf_len] = 0;

	while (current_node) {
		ret = strstr(kern_buf, current_node->pattern);
		if (ret) {
			pr_info(" match found!\n");
			kfree(kern_buf);
			return 1;
		}
		current_node = current_node->next;
	}

	pr_info("no match found\n");
	kfree(kern_buf);
	return 0;
}

/**
 * traverse
 * @mylist:  Pointer to linked list
 *
 * Traverses the linked list. Useful for debugging.
 *
 * Doesn't return anything
 */
void traverse(List *mylist)
{
	Node *temp = mylist->head;

	while (temp) {
		pr_info("Current node has string %s\n", temp->pattern);
		pr_info("lenght of sting = %d\n", temp->len);
		pr_info("hashtable entry = %d\n",
			mylist->hash_table[temp->pattern[0] - 33]);
		pr_info("temp = %u\n", (int)temp);
		if (temp->next)
			pr_info("temp->next = %u\n", (int)(temp->next));
		temp = temp->next;
	}
}

/**
 * set_max_pattern_len
 *
 * Traverses the linked list and sets the maximum length of pattern
 * present in linked list
 *
 * Doesn't return anything
 */
void set_max_pattern_len(void)
{
	Node *current_node = pattern_list.head;

	pattern_list.max_pattern_len = 0;
	while (current_node) {
		if (current_node->len >= pattern_list.max_pattern_len)
			pattern_list.max_pattern_len = current_node->len;
		current_node = current_node->next;
	}
}

/**
 * delete_pattern
 * @mylist:  Pointer to linked list of patterns in memory
 * @pattern_to_delete : pattern to be deleted
 * @len : length of pattern to be deleted
 *
 * Scans the linked list to delete the pattern if it's present.
 *
 * Returns 0 on success; non-zero otherwise
 */
int delete_pattern(List *mylist, char *pattern_to_delete, int len)
{
	int err = 0;
	Node *prev_node = NULL;
	Node *current_node = pattern_list.head;

	if (pattern_list.hash_table[pattern_to_delete[0] - 33] == 0) {
		pr_info("pattern doesn't exist in list\n");
		return -EINVAL;
	}
	/* scenario when the node to delete is head node*/
	if (current_node && current_node->len == len &&
	    strncmp(current_node->pattern, pattern_to_delete, len) == 0) {
		pr_info("node to delete found at head\n");
		pattern_list.head = current_node->next;
		kfree(current_node);
		if (pattern_list.max_pattern_len == len)
			set_max_pattern_len();
		goto out;
	}
	/* while current_node has value and till we haven't found the match,*/
	/*keep going ahead*/
	while (current_node &&
	       strncmp(current_node->pattern, pattern_to_delete, len) != 0) {
		prev_node = current_node;
		current_node = current_node->next;
	}
	/* we've reached the end but didn't find pattern*/
	if (!current_node) {
		pr_info("pattern not found in list\n");
		return -EINVAL;
	}

	/*If we've reached here, means we've found the node*/
	pr_info("found the node to delete");
	prev_node->next = current_node->next;
	kfree(current_node);
	pr_info("pattern_removed count updated to %d\n",
		pattern_list.pattern_removed);
	if (pattern_list.max_pattern_len == len)
		set_max_pattern_len();

out:
	pattern_list.pattern_removed += 1;
	pattern_list.size -= 1;
	pattern_list.hash_table[pattern_to_delete[0] - 33] -= 1;

	return err;
}

/**
 * delete_list
 * @mylist:  Pointer to linked list of patterns
 *
 * Deletes the entire linked list and frees the memory.
 *
 * Doesn't return anything
 */
void delete_list(List *mylist)
{
	Node *current_node = mylist->head;
	Node *next_node;

	while (current_node) {
		next_node = current_node->next;
		pr_info("now freeing node with pattern %s\n",
			current_node->pattern);
		kfree(current_node);
		pr_info("freed!");
		if (next_node)
			pr_info("current->next = %u\n", (int)next_node);
		current_node = next_node;
	}
	pr_info("all nodes freed!");
	mylist->head = NULL;
	mylist->size = 0;
}

/**
 * sorted_insert
 * @pattern_list:  Pointer to linked list of patterns
 * @buf: pattern to be inserted
 * @start: starting position of the pattern
 * @end: ending position of the pattern
 *
 * Inserts the string between buf[start] and buf[end-1] in sorted order
 * in the linked list. When this is invoked on pattern.db is loaded,
 * buf contains all patterns separated by \n so we need start and end index.
 * If this is invoked from ADD_PATTERN IOCTL, buf has pattern
 * to be added, start is 0 and end will be length of the pattern
 *
 * Returns 0 on successful insert; non-zero otherwise
 */
int sorted_insert(List *pattern_list, char *buf, int start, int end)
{
	int i, j = 0, index, res;
	int pattern_len = end - start + 1;
	Node *current_node, *prev_node;
	Node *pattern_node;

	if (pattern_len > 256) {
		pr_info("Cannot add pattern with length greater than 256\n");
		return -E2BIG;
	}

	pattern_node = kmalloc(sizeof(Node) + pattern_len, GFP_KERNEL);

	if (!pattern_node) {
		pr_info("error kmallocing node for linked list");
		return -ENOMEM;
	}

	for (i = start; i < end; i++, j++)
		pattern_node->pattern[j] = buf[i];

	pattern_node->pattern[end - start] = 0;
	pattern_node->len = strlen(pattern_node->pattern);

	if (pattern_node->len > pattern_list->max_pattern_len)
		pattern_list->max_pattern_len = pattern_node->len;

	/* list is empty */
	if (!pattern_list->head) {
		pattern_list->head = pattern_node;
		pattern_node->next = NULL;
	} else {
		prev_node = NULL;
		current_node = pattern_list->head;
		while ((res = strcmp(pattern_node->pattern, current_node->pattern)) >= 1) {
			prev_node = current_node;
			current_node = current_node->next;
			if (!current_node)
				break;
		}

		if (!prev_node) {
			/* we've to add at head*/

			if (res == 0) {
				pr_info("found a duplicate node\n");
				kfree(pattern_node);
				return -EINVAL;
			}
			pattern_node->next = current_node;
			pattern_list->head = pattern_node;
		} else if (!current_node) {
			/*we've to add at tail*/

			prev_node->next = pattern_node;
			pattern_node->next = NULL;
		} else {
			/*we've to add in between*/

			if (res	== 0) {
				pr_info("found a duplicate node\n");
				kfree(pattern_node);
				return -EINVAL;
			}

			prev_node->next = pattern_node;
			pattern_node->next = current_node;
		}
	}

	index = buf[start] - 33;
	pattern_list->hash_table[index] += 1;
	pattern_list->size += 1;

	return 0;
}

/**
 * build_linked_list
 * @buf:  data read from pattern.db file
 *
 * Scans the buffer. Gets the valid indices of patterns
 * present in the buffer and calls sorted_insert to insert
 * the pattern in sorted order inside linked list
 *
 * Returns 0 on success;non-zero otherwise
 */
int build_linked_list(char *buf)
{
	int new_line_index;
	int err = 0, start = 0;

	init_list(&pattern_list);
	while (1) {
		new_line_index = get_newline_index(start + buf);
		if (new_line_index == -1)
			break;

		if (start == start + new_line_index) {
			start = start + 1;
			if (start >= strlen(buf))
				break;
			else
				continue;
		}

		pr_info("start = %d and end = %d\n", start,
			start + new_line_index);
		err = sorted_insert(&pattern_list, buf,
				    start, start + new_line_index);

		if (err)
			return err;

		start = start + new_line_index + 1;
		if (start >= strlen(buf))
			break;
	}

	if (start < strlen(buf))
		sorted_insert(&pattern_list, buf, start, start + strlen(buf));

	traverse(&pattern_list);
	return err;
}

/**
 * flush_to_file
 *
 * Writes the data in linked list back to pattern.db file.
 * We also set the extended attribute on pattern.db file to maintain state
 * on subsequent mount. We also set the immutable attribute on pattern file
 * so that it cannot be tampered with.
 *
 * Returns 0 on success;non-zero otherwise
 */
int flush_to_file(void)
{
	int err = 0, tmp_err;
	Node *current_head;
	struct dentry *lower_old_dentry;
	struct dentry *lower_new_dentry;
	struct dentry *lower_old_dir_dentry;
	struct dentry *lower_new_dir_dentry;
	struct dentry *trap = NULL;
	struct file *temp_file, *patt_file;
	mm_segment_t oldfs;
	char *temp_file_path = NULL;

	temp_file_path = kmalloc(strlen(pattern_list.full_path) + 5,
				 GFP_KERNEL);
	strcpy(temp_file_path, pattern_list.full_path);
	strcat(temp_file_path, ".tmp");
	pr_info("full path for temp file  = %s\n", temp_file_path);
	pr_info("full path for pattern file = %s\n", pattern_list.full_path);
	temp_file = filp_open(temp_file_path, O_WRONLY | O_CREAT,
			      0666 - current_umask());

	if (!(temp_file) || IS_ERR(temp_file)) {
		pr_info("Files tempfile  does not exist\n");
		err = PTR_ERR(temp_file);
		goto out;
	}

	patt_file = filp_open(pattern_list.full_path, O_RDONLY,
			      0666 - current_umask());

	if (!(patt_file) || IS_ERR(patt_file)) {
		pr_info("Files pattern.db  does not exist\n");
		err = PTR_ERR(patt_file);
		goto temp;
	 }

	/* unset chattr so that we can rename the file*/
	err = set_or_unset_chattr(patt_file, 0);
	if (err)
		pr_info("some error in chattr %d\n", err);

	current_head = pattern_list.head;
	oldfs = get_fs();
	set_fs(KERNEL_DS);

	while (current_head) {
		err = vfs_write(temp_file, current_head->pattern,
				current_head->len, &temp_file->f_pos);
		if (err < 0) {
			pr_info("write failed\n");
			set_fs(oldfs);
			goto  patt;
		}
		err = vfs_write(temp_file, "\n", 1, &temp_file->f_pos);
		current_head = current_head->next;
	}

	set_fs(oldfs);

	/*save the remove count on file since we need it next time*/
	err = temp_file->f_inode->i_op->setxattr(temp_file->f_path.dentry,
						 "user.patternrm",
						 (void *)&pattern_list.pattern_removed,
						 sizeof(int), 0);

	/*lock the file using chattr*/
	lower_old_dentry = temp_file->f_path.dentry;
	lower_old_dir_dentry = dget_parent(lower_old_dentry);
	lower_new_dentry = patt_file->f_path.dentry;
	lower_new_dir_dentry = dget_parent(lower_new_dentry);

	trap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);

	err = vfs_rename(d_inode(lower_old_dir_dentry), lower_old_dentry,
			 d_inode(lower_new_dir_dentry), lower_new_dentry,
			 NULL, 0);
	if (err) {
		pr_info("error in rename\n");
		tmp_err = err;

		err = vfs_unlink(d_inode(temp_file->f_path.dentry->d_parent),
				 temp_file->f_path.dentry, NULL);
		if (err)
			pr_info("Error in unlink\n");

		err = tmp_err;
	}
	pr_info("rename done!\n");
	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
	tmp_err = set_or_unset_chattr(temp_file, 1);
	if (tmp_err)
		pr_info("some error in chattr %d\n", tmp_err);

patt:
	if (patt_file)
		filp_close(patt_file, NULL);
temp:
	if (temp_file)
		filp_close(temp_file, NULL);
out:
	kfree(temp_file_path);
	return err;
}

/**
 * set_or_unset_chattr
 * @pattern_file:  pattern.db file on which we need to set/unset attribute
 * @param: flag to determine operation to be performed.
 * 1 to set the attribute, 0 to unset the attribute
 *
 * Sets or unsets the immutable attribute on pattern file.
 * This is same as doing chattr +i pattern_file or chattr -i pattern_file
 *
 * Returns 0 on success; non-zero otherwise
 */
int set_or_unset_chattr(struct file *pattern_file, int param)
{
	mm_segment_t old_fs;
	int temp, flags = 0;

	old_fs = get_fs();
	set_fs(KERNEL_DS);
	temp = pattern_file->f_op->unlocked_ioctl(pattern_file,
						  FS_IOC_GETFLAGS,
						  (unsigned long)&flags);
	set_fs(old_fs);
	pr_info("temp = %d\n", temp);
	if (param)
		flags |= FS_IMMUTABLE_FL;
	else
		flags &= ~FS_IMMUTABLE_FL;

	if (temp == 0) {
		pr_info("first ioctl success\n");
		old_fs = get_fs();
		set_fs(KERNEL_DS);
		temp = pattern_file->f_op->unlocked_ioctl(pattern_file,
							  FS_IOC_SETFLAGS,
							  (unsigned long)&flags);
		set_fs(old_fs);
		pr_info("temp = %d\n", temp);
	}

	return temp;
}

/**
 * set_xattr
 * @file: file on which we need to set extended attribute
 * @name: name of extended attribute
 * @value: value of extended attribute
 * @size: size of value of extended attribute
 *
 * Sets the name:value pair on file.
 *
 * Returns 0 on success; non-zero otherwise
 */
int set_xattr(struct file *file, const char *name, void *value, int size)
{
	return file->f_inode->i_op->setxattr(file->f_path.dentry,
					     name, value, size, 0);
}

/**
 * remove_xattr
 * @file: file on which we need to set extended attribute
 * @name: name of extended attribute to remove
 *
 * Removes the name attribute of file.
 *
 * Returns 0 on success; non-zero otherwise
 */
int remove_xattr(struct file *file, const char *name)
{
	return file->f_inode->i_op->removexattr(file->f_path.dentry, name);
}

/**
 * get_xattr
 * @file: file on which we need to set extended attribute
 * @name: name of extended attribute to retrieve
 * @value: value of extended attribute
 * @size: size of value of extended attribute
 *
 * Retrieves the value for attribute name on file.
 *
 * Returns size on success; non-zero otherwise
 */
int get_xattr(struct file *file, const char *name, void *value, int size)
{
	return file->f_inode->i_op->getxattr(file->f_path.dentry,
					     name, value, size);
}
